/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'Glauber' at '3/26/16 9:54 AM' with Gradle 2.11
 *
 * @author Glauber, @date 3/26/16 9:54 AM
 */
package com.gmrodrigues.dependencyresolver4j;

import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Resolver<T>
{
    private final Multimap<T, T> deps;

    public Resolver()
    {
        deps = ArrayListMultimap.create();
    }

    public void addDependency(T item, T dep)
    {
        deps.put(item, dep);
    }

    public List<T> resolve() throws CircularReferenceException
    {
        Map<T, Node> nodeMap = new HashMap<T, Node>();
        for (T item : deps.keys()) {
            Node node = new Node(item, Optional.fromNullable(deps.get(item)));
            if (!nodeMap.containsKey(item)) {
                nodeMap.put(item, node);
            }
        }
        for (T item : deps.values()) {
            Node node = new Node(item, Optional.fromNullable(deps.get(item)));
            if (!nodeMap.containsKey(item)) {
                nodeMap.put(item, node);
            }
        }

        List<T> resolved = new ArrayList<T>();
        List<T> unresolved = new ArrayList<T>();
        depResolve(nodeMap.values().iterator().next(), resolved, unresolved, nodeMap);

        return resolved;
    }

    private void depResolve(Node node, List<T> resolved, List<T> unresolved, Map<T, Node> nodeMap) throws CircularReferenceException
    {
        unresolved.add(node.item);
        if (node.deps.isPresent()) {
            for (T dep : node.deps.get()) {
                if (!resolved.contains(dep)) {
                    if (unresolved.contains(dep)) {
                        throw new CircularReferenceException(String.format("Circular reference detected %s(%s)", node.item, dep));
                    }
                    depResolve(nodeMap.get(dep), resolved, unresolved, nodeMap);
                }
            }
        }
        resolved.add(node.item);
        unresolved.remove(node.item);
    }

    private class Node
    {
        private T item;
        private Optional<Collection<T>> deps;

        public Node(T item, Optional<Collection<T>> deps)
        {
            this.item = Preconditions.checkNotNull(item, "item is null");
            this.deps = Preconditions.checkNotNull(deps, "deps is null");
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            Node node = (Node) o;

            return item.equals(node.item);
        }

        @Override
        public int hashCode()
        {
            return item.hashCode();
        }
    }
}
